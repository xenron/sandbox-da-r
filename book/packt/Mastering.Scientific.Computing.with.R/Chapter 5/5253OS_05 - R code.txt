


a <- c(1,2,3,4)
b <- matrix(a, nrow = 1)
a
b


matrix(c(1:24), nrow = 2)
matrix(c(1:24), ncol = 12)
diag(c(1:3), 3, 3)
diag(5)  



phys.func <- read.csv('phys_func.txt')[,c(-1)]
phys.func.mat <-  as.matrix(phys.func)

cor.mat <- matrix(cor(phys.func), ncol = 20) 
phys.brief.mat <- as.matrix(phys.func[c(1:30),])

phys.brief.mat 

#Element-wise operations
phys. brief.mat + matrix(rnorm(600), ncol = 20)
phys.brief.mat / sd(phys.brief.mat)


mean.phys <- apply(phys.brief.mat, 2, mean) 
phys.sweep.1 <- sweep(phys.brief.mat, 2, mean.phys, '-')

sd.phys <- apply(phys.sweep.1, 2, sd)
phys.sweep.2 <- sweep(phys.sweep.1, 2, sd.phys, '/')
phys.scaled <- scale(phys.brief.mat, center = TRUE, scale = TRUE)

colMeans(phys.brief.mat)

phys.sweep.2 / phys.scaled

#Matrix-wise operations
t(phys.mat)

A <- matrix(c(rep(2,3), rep(5,3)), ncol = 2, byrow = FALSE) 
B <- matrix(c(1:16), nrow = 2, byrow = TRUE)
C <- matrix(1, ncol = 2, nrow =3 , byrow = FALSE)
A %*% B
B %*% A
C %*% A
A %*% t(C)


small.network <- matrix(c(0,1,1,0,1,0,1,0,1,0,0,0,1,0,0,1,0,1, 0, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0, 1, 0), nrow = 6, byrow = TRUE)

apply(small.network, 1, sum)

apply((small.network %*% small.network), 1, sum)


apply((small.network %*%  small.network + small.network), 1, sum)

set.seed(51) 
social.network.mat <- matrix(sample(c(0,1), 1000000, replace = TRUE, prob = c(0.7, 0.3)), ncol = 1000)
diag(social.network.mat)<-0

influence.1 <- apply(social.network.mat, 1, sum)

second.degree.mat <- social.network.mat %*% social.network.mat
influence.2 <- apply(second.degree.mat, 1, sum)

influence.1.2 <- apply(social.network.mat + second.degree.mat, 1, sum)


x<- c(1:3)
y<- c(4:6)
outer(x, y)  
x %o% y
outer(x, y, FUN = '+')

M <- matrix(rep(1, 9), nrow = 3)
N <- diag(c(1:3), nrow = 3)
P <- matrix(rep(c(1:3),3), nrow = 3)
Q <- matrix(1, nrow = 3)
M
N
P
Q 

M %*% N 
N %*% M
P %*% Q
phys.func.mat <-  as.matrix(phys.func)
total.scores <- phys.func.mat %*% matrix(rep(1, 20), nrow = 20)

design.matrix <- matrix(rep(0, 60), nrow = 20)
#Place 1’s for the cognitive domain
design.matrix[c(1,17,18,19), 1] <- 1
# Place 1’s for the lower extremity domain
design.matrix[c(2,3,4,8,9,10,13,14), 2] <- 1
# Place 1’s for the upper extremity domain
design.matrix[c(5, 6, 7, 11, 12, 15, 16, 20), 3] <- 1

total.scores <- phys.func.mat %*% design.matrix
summary(total.scores)

solve(cor.mat)
cor.mat %*% solve(cor.mat)

Y <- as.matrix(read.csv('coefficients_matrix.csv')[,12] )
C <- as.matrix(read.csv('coefficients_matrix.csv')[,c(2:11)]) 
X <- solve(C) %*% Y
X

solve(C, Y)

C.2 <- matrix(sample(c(1:100), 1000000, replace = TRUE), nrow = 1000)
Y.2 <- matrix(sample(c(1:1000), 1000, replace = TRUE), nrow = 1000)
solve(C.2, Y.2)

det(cor.mat)

triangle.matrix <- cor.mat 
triangle.mat[upper.tri(triangle.matrix)] <- 
triangle.matrix


eigen(cor.mat)$values
eigen(cor.mat)$vectors
cor.mat %*% eigen(cor.mat)$vectors[,1]
eigen(cor.mat)$values[1] * eigen(cor.mat)$vectors[,1]


library(Matrix)
lu.mat <- expand(lu(C))
lower.mat <- lu.mat$L
upper.mat <- lu.mat$U
p.mat <- lu.mat$P

p.mat %*% lower.mat %*% upper.mat


chol(cor.mat)


t(chol(cor.mat)) %*% chol(cor.mat)

cross.mat <- matrix(
	c(
		0, 0, 0, 1, 1, 0, 0, 0,
		0, 0, 0, 1, 1, 0, 0, 0,
		0, 0, 0, 1, 1, 0, 0, 0,
		1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1,
		0, 0, 0, 1, 1, 0, 0, 0,
		0, 0, 0, 1, 1, 0, 0, 0,
		0, 0, 0, 1, 1, 0, 0, 0
	), 
byrow = TRUE, nrow = 10)

cross.svd <- svd(cross.mat)

cross.svd$d

cross.svd$u[,c(1,2)] %*% diag(cross.svd$d[c(1,2)]) %*% t(cross.svd$v[, c(1,2)])

round(cross.svd$u[,c(1,2)] %*% diag(cross.svd$d[c(1,2)]) %*% t(cross.svd$v[, c(1,2)]), 0)


cross.mat <- matrix(
	c(
		0, 0, 0, 1, 1, 0, 0, 0,
		1, 0, 0, 1, 1, 0, 0, 0,
		0, 0, 0, 1, 1, 0, 0, 0,
		1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1,
		1, 1, 1, 1, 1, 1, 1, 1,
		0, 0, 0, 1, 1, 0, 0, 0,
		0, 0, 0, 1, 1, 0, 0, 0,
		0, 0, 0, 1, 1, 0, 0, 0
	)
,byrow = TRUE, nrow = 10)

cross.svd <- svd(cross.mat)
round(cross.svd.2$u[,c(1,2)] %*% diag(cross.svd.2$d[c(1,2)]) %*% t(cross.svd.2$v[, c(1,2)]), 0)
 

#Rasch analysis
lower.extremity.mat <- phys.func.mat[,c(2,3,4,8,9,10,13,14)]
lower.extremity.binary <- replace(lower.extremity.mat, which(lower.extremity.mat %in% c(2:5)), 0)


create.paired.comparisons <- function (input.matrix) {
	n.items <- ncol(input.matrix)
	output.matrix <- matrix(0, nrow = n.items, ncol = n.items)
	for (i in 1:n.items) {
		for (j in 1:n.items) {
			output.matrix[i, j] <- length(which(input.matrix[,i] - input.matrix[,j] > 0))
		}
	}
	return(output.matrix)
}

R <- create.paired.comparisons(lower.extremity.binary) 
R
D <- t(R) / R
diag(D) <- rep(1, 8)
D
ln.D <- log(D, exp(1))
(ln.D %*% matrix(rep(1, 8), nrow = 8)) / 8


#Coefficient Alpha
domain.totals <- phys.func.mat %*% design.matrix
tot.score.var <- diag(cov(domain.totals))
item.var <- diag(cov(phys.func.mat))
item.var <- matrix(item.var, ncol = 20)

item.var.tot <- item.var %*% design.matrix
n <- matrix(1, ncol = 20) %*% design.matrix

alpha <- (n / (n-1)) * (1 - (item.var.tot / tot.score.var))
alpha


#Image compression
library(png)
picture <- readPNG('landscape.png')
dim(picture)

picture.1 <- picture[,,1]
image(t(picture.1)[,nrow(picture.1):1], col = gray(seq(0,1, length.out = 256)))
picture.1.256 <- round(picture.1 * 255 -128)
create.dct.matrix <- function(n) {
	output.matrix <- matrix(0, nrow = n, ncol = n)
	for (i in 1:n) {
		for (j in 1:n) {
			if (i == 1) {output.matrix[i,j] <- 1/sqrt(n)}
			if (i > 1) {
				output.matrix[i,j] <- 
				 sqrt(2 / n) * cos( (2*(j-1) +1)*(i-1)*pi / (2* n))
			}
		}
	}
	return(output.matrix)
}


quant.matrix <- matrix(
	c(
	16,11,10,16,24,40,51,60,
	12,12,14,19,26,58,60,55,
	14,13,16,24,40,57,69,56,
	14,17,22,29,51,87,80,62,
	18,22,37,59,68,109,103,77,
	24,35,55,64,81,104,113,92,
	49,64,78,87,103,121,120,101,
	72,92,95,98,112,100,103,99
	),
	byrow = TRUE,
	nrow = 8, ncol = 8
)

compression.ratio <- 50

Q <- round(quant.matrix * (100-compression.ratio)/50)
T <- create.dct.matrix(8)

dct.compress <- function(input.matrix) {
	input.row <- nrow(input.matrix)
	input.col <- ncol(input.matrix)
	
	output.matrix <- matrix(0, nrow = input.row, ncol = input.col)
	
	working.row <- c(1:8)
			
	while (max(working.row) <= input.row) {
		working.col	<- c(1:8)

		while (max(working.col) <= input.col) {
			output.matrix[working.row, working.col] <- 
			(T %*% input.matrix[working.row, working.col] %*% t(T))/Q
			
			working.col <- working.col + 8
		}
		working.row <- working.row + 8
	}
	
	return(output.matrix)
}

picture.compressed <- dct.compress(picture.1.256)
image(t(picture.compressed)[,nrow(picture.compressed):1], col = gray(seq(1,0, length.out = 2)))



decompress.image <- function(input.matrix) {
	input.row <- nrow(input.matrix)
	input.col <- ncol(input.matrix)
	
	output.matrix <- matrix(0, nrow = input.row, ncol = input.col)
	
	working.row <- c(1:8)
			
	while (max(working.row) <= input.row) {
		working.col	<- c(1:8)

		while (max(working.col) <= input.col) {
			output.matrix[working.row, working.col] <- 
			(t(T) %*% (Q * input.matrix[working.row, working.col]) %*% T)
			working.col <- working.col + 8
		}
		working.row <- working.row + 8
	}
	
	return(output.matrix)
}

picture.decompressed <- decompress.image(picture.compressed)
image(t(picture.decompressed)[,nrow(picture.decompressed):1], col = gray(seq(0,1, length.out = 256)))
 


